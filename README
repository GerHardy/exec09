This is a rewrite of Arto Salmi's 6809 simulator.  Many changes
have been made to it.  This program remains licensed under the
GNU General Public License.

-----------------------------------------------------------------
Build and install (on Linux)

you will need make, gcc, aclocal, automake and probably some other
stuff. Then:

> ./configure
> make

There is one executable, m6809-run. You can install it
("make install") or simply reference it explicitly.

To see configure options:

> ./configure --help

Enable readline libraries if you have them installed; this will
allow you to use command-line recall and other shortcuts at the
debugger command-line:

> ./configure --enable-readline
> make

-----------------------------------------------------------------
Input Files


-----------------------------------------------------------------
Machines


The simulator now has the notion of different 'machines':
which says what types of I/O devices are mapped into the 6809's
address space and how they can be accessed.  Adding support for
a new machine is fairly easy.

There are 5 builtin machine types at present:

* 'simple' - assumes that you have a full 64KB of RAM,
minus some input/output functions mapped at $FF00 (see I/O below).
If you compile a program with gcc6809 with no special linker
option, you'll get an S-record file that is suitable for running
on this machine.  The S-record file will include a vector table
at $FFF0, with a reset vector that points to a _start function,
which will call your main() function.  When main returns,
_start writes to an 'exit register' at $FF01, which the simulator
interprets and causes it to stop.

gcc6809 also has a builtin notion of which addresses are used
for text and data.  The simple machine enforces this and will
"fault" on invalid accesses.

* 'wpc' - an emulation of the
Williams Pinball Controller which was the impetus for me
working on the compiler in the first place.

* 'eon' (and 'eon2') - still in development, is called 'eon'
(for Eight-O-Nine).  It is similar to simple but has some
more advanced I/O capabilities, like a larger memory space
that can be paged in/out, and a disk emulation for programs
that wants to have persistence.

* 'multicomp09' - see miscsbc.c for details

* 'smii' - see miscsbc.c for details

* 'kipper1' - see miscsbc.c for details

TODO : Would anyone be interested in a CoCo machine type?

-----------------------------------------------------------------
Faults


-----------------------------------------------------------------
Debugging


The simulator supports interactive debugging similar to that
provided by 'gdb'.

b <expr>
	Set a breakpoint on EXECUTION at the given address. Eg:
	break 0xf003
	- break next time
	break 0xf000 ignore 4
	- ignore 4 times then break on 5th time
	break 0x1200 if <expression>
	break 0x1200 if $s==02:0x0043
	- break if the S register has the value shown.

wa <expr>
	Set a watchpoint on WRITE to the given address. Eg:
	wa 0xf003
	- break and report on each write to this address.
	wa 0xf003 print
	- on each write to this address report but do not stop
	  execution.
	wa 0xf003 mask 0x10
	- break and report on each write to this address but
	  only if the write data ANDed with the mask value is
	  non-zero.

rwa <expr>
	Set a watchpoint on READ from the given address. See
	examples above for 'wa'.

awa <expr>
	Set a watchpoint on ACCESS (read or write) at the given
	address. See examples above for 'wa'.

bl
	List all breakpoints/watchpoints.

d <num>
	Delete a breakpoint/watchpoint.

c
	Continue execution.

di <expr>
	Add a display expression. The value of the expression
	is displayed any time that the CPU breaks. Eg:
	di $d $x $y
	- print current value of D X and Y registers each time
	  the CPU breaks.

dump
	Save machine-specific state information to a file,
	typically named <machine>.dmp. The dump might be
	in readable or in binary format.

dumpi <1 | 0>
	Turn instruction dump on or off. With no argument, report
	the current instruction dump state (on or off).
	With instruction dump off, the 'c', 'n', 's' commands
        will report the last instruction that was executed before
	control returned to the prompt. With instruction dump on,
	those commands report each instruction as it is executed.
	Instruction dump is OFF by default.

h or ?
	Display help.

l <expr>
	List (disassemble) CPU instructions. Default is to start
	at the current value of the PC.

me <expr>
	Measure the amount of time that a function named by
	<expr> takes.

n
	Continue execution until the Next instruction is reached.
	If the current instruction is a call, then the debugger
	resumes after control returns.

p <expr>
	Print the value of an expression. See "Expressions" below.

pc <expr>
	Set the CPU program counter to <expr> and list
	(disassemble) CPU instructions at that address. Without
	<expr>, acts like 'regs'.

q
	Quit the simulator.

regs
	Display the current value of the CPU registers.


re
	Reset the CPU/machine.

restore
	Restore machine state from a 'dump' file. NOT CURRENTLY
	IMPLEMENTED.

runfor <expr>
	Continue but break after a certain period of (simulated) time.

s  <expr>
	Step for a certain number of CPU instructions (1 by default).

set <expr>
	Sets the value of an internal variable or target memory.
	See "Expressions" below for details on the syntax.

so <file>
	Run a set of debugger commands from another file.
	The commands may start/stop the CPU.  When the commands
	are finished, control returns to the previous input
	source (the file that called it, or the keyboard.)

sym <file>
	Load a symbol table file.  Currently, the only format
	supported is lwlink map file.

td
	Trace Dump. Display the last 256 instructions that were
	executed.

vars
	Show all program variables.

x <expr>
	Examine target memory at the address given. Eg:
	x/nfu addr
	- nfu specifies number, format, unit respectively. See
          below.
	x/nfu
	- continue from previous address, in new format.
	x addr
	- use previous format, continue from previous address.
	x
	- use previous format, continue from previous address.

	n is the repeat count (default 1). It specifies how much
	  memory (counting by units u to display. Display is
	  formated multi-line if necessary.
	f is the display format (default x for hex). Options:
	  x X d u o a s (match printf) and i (instructions).
	u is the unit size (default b for byte). Options:
	  b (byte) w (word: 2 bytes)

	The addr can be specified as an expression. Eg:
	x $pc
	x $pc+8

	white-space is not supported in the expression, so
	that '$pc +8' is treated in the same way as '$pc'.

info
        Describe machine, devices and address mapping.

-----------------------------------------------------------------
Symbol Tables

Exec09 maintains variables, in 3 separate symbol tables:

- The program table. This is loaded automatically at startup or
  using the 'sym' command. The contents of this table is
  displayed by the 'vars' command.
  Entries in the program table are annotated onto 'list', 'step'
  'x' output.

- The auto table. The variables in this table are pre-defined.
  The following variables refer to CPU registers:
    pc a y u s d a b dp cc
  The following variables refer to simulator state:
    cycles - number of cycles since reset.
    et - number of cycles elapsed since et was last inspected.
    irqload - the average number of cycles spent in IRQ.

  Auto variables can be referenced in expressions using a $ prefix.

- The internal table. The ...




-----------------------------------------------------------------
Expressions

set
        does nothing

set foo
        do_set foo
set var
        do_set $

set var foo
        do_set foo (ie, same as 'set foo')

-----------------------------------------------------------------
Original README text from Arto:


simple 6809 simulator under GPL licence

NOTE! this software is beta stage, and has bugs.
To compile it you should have 32-bit ANSI C complier.

This simulator is missing all interrupt related SYNC, NMI Etc...

I am currently busy with school, thus this is relased.
if you have guestion or found something funny in my code please mail me.

have fun!

arto salmi	asalmi@ratol.fi

history:

2001-01-28 V1.0  original version
2001-02-15 V1.1  fixed str_scan function, fixed dasm _rel_???? code.
2001-06-19 V1.2  Added changes made by Joze Fabcic:
                 - 6809's memory is initialized to zero
                 - function dasm() had two bugs when using vc6.0 complier:
                   - RDWORD macro used two ++ in same variable
                   - _rel_byte address was wrong by 1.
                - after EXIT command, if invalid instruction is encountered, monitor is activated again
                - default file format is motorola S-record
                - monitor formatting


